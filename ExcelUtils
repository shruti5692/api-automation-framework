package com.framework.utils;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.util.*;

/**
 * Generic Excel reader & writer.
 * - readSheet returns List<Map<header, value>> where value is raw string.
 * - writeResult writes a "Result" cell for the matching TestCaseID.
 * - writeResultWithDuration also writes DurationSec (test execution time).
 */
public class ExcelUtils {

    // ---------------- Existing Methods (unchanged) ---------------- //

    public static List<Map<String, String>> readSheet(String excelPath, String sheetName) throws Exception {
        List<Map<String, String>> list = new ArrayList<>();
        try (FileInputStream fis = new FileInputStream(excelPath);
             Workbook wb = new XSSFWorkbook(fis)) {
            Sheet sheet = wb.getSheet(sheetName);
            if (sheet == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

            // header
            Row headerRow = sheet.getRow(0);
            if (headerRow == null) return list;
            List<String> headers = new ArrayList<>();
            for (Cell c : headerRow) {
                c.setCellType(CellType.STRING);
                headers.add(c.getStringCellValue().trim());
            }

            for (int r = 1; r <= sheet.getLastRowNum(); r++) {
                Row row = sheet.getRow(r);
                if (row == null) continue;
                Map<String, String> map = new LinkedHashMap<>();
                boolean nonEmpty = false;
                for (int c = 0; c < headers.size(); c++) {
                    Cell cell = row.getCell(c);
                    String val = "";
                    if (cell != null) {
                        if (cell.getCellType() == CellType.NUMERIC) {
                            double d = cell.getNumericCellValue();
                            long l = (long) d;
                            val = String.valueOf(l);
                        } else {
                            cell.setCellType(CellType.STRING);
                            val = cell.getStringCellValue();
                        }
                    }
                    if (val != null && !val.trim().isEmpty()) nonEmpty = true;
                    map.put(headers.get(c), val == null ? "" : val.trim());
                }
                if (nonEmpty) list.add(map);
            }
        }
        return list;
    }

    public static void writeResult(String excelPath, String sheetName, String testCaseId, String result) throws Exception {
        writeResultWithDuration(excelPath, sheetName, testCaseId, result, null);
    }

    // ---------------- New/Extended Method ---------------- //

    /**
     * Writes both Result and (optionally) DurationSec for a test case.
     *
     * @param excelPath    Excel file path
     * @param sheetName    Sheet name
     * @param testCaseId   TestCaseID to update
     * @param result       PASS/FAIL text
     * @param durationSec  Duration in seconds (nullable; if null, only Result is written)
     */
    public static void writeResultWithDuration(String excelPath,
                                               String sheetName,
                                               String testCaseId,
                                               String result,
                                               Long durationSec) throws Exception {

        FileInputStream fis = new FileInputStream(excelPath);
        Workbook wb = new XSSFWorkbook(fis);
        fis.close();

        Sheet sheet = wb.getSheet(sheetName);
        if (sheet == null) throw new IllegalArgumentException("Sheet not found: " + sheetName);

        Row header = sheet.getRow(0);
        int cols = header.getLastCellNum();
        int resultCol = -1;
        int tcCol = -1;
        int durationCol = -1;

        // locate or create Result / DurationSec columns
        for (int i = 0; i < cols; i++) {
            Cell c = header.getCell(i);
            if (c == null) continue;
            c.setCellType(CellType.STRING);
            String h = c.getStringCellValue().trim();
            if ("Result".equalsIgnoreCase(h)) resultCol = i;
            if ("TestCaseID".equalsIgnoreCase(h)) tcCol = i;
            if ("DurationSec".equalsIgnoreCase(h)) durationCol = i;
        }
        if (tcCol == -1) throw new IllegalArgumentException("TestCaseID header not found in Excel");

        if (resultCol == -1) {
            resultCol = cols++;
            header.createCell(resultCol, CellType.STRING).setCellValue("Result");
        }
        if (durationSec != null && durationCol == -1) {
            durationCol = cols++;
            header.createCell(durationCol, CellType.STRING).setCellValue("DurationSec");
        }

        boolean updated = false;
        for (int r = 1; r <= sheet.getLastRowNum(); r++) {
            Row row = sheet.getRow(r);
            if (row == null) continue;
            Cell tcCell = row.getCell(tcCol);
            if (tcCell == null) continue;
            tcCell.setCellType(CellType.STRING);
            String tc = tcCell.getStringCellValue().trim();
            if (tc.equals(testCaseId)) {
                // Result
                Cell res = row.getCell(resultCol);
                if (res == null) res = row.createCell(resultCol, CellType.STRING);
                res.setCellValue(result);

                // Duration (if provided)
                if (durationSec != null) {
                    Cell dur = row.getCell(durationCol);
                    if (dur == null) dur = row.createCell(durationCol, CellType.NUMERIC);
                    dur.setCellValue(durationSec);
                }
                updated = true;
                break;
            }
        }

        try (FileOutputStream fos = new FileOutputStream(excelPath)) {
            wb.write(fos);
        }
        wb.close();

        if (!updated)
            throw new IllegalStateException("Could not find TestCaseID " + testCaseId + " to write result/duration");
    }

    // ---------------- Existing helper remains ---------------- //
    public static Map<String,String> jsonToMap(String json) {
        Map<String,String> map = new LinkedHashMap<>();
        if (json == null || json.trim().isEmpty()) return map;

        String trimmed = json.trim();
        if (trimmed.startsWith("{") && trimmed.endsWith("}")) {
            trimmed = trimmed.substring(1, trimmed.length()-1);
        }
        String[] pairs = trimmed.split("\\s*,\\s*");
        for (String p : pairs) {
            if (p.isEmpty()) continue;
            String[] kv = p.split("\\s*:\\s*", 2);
            if (kv.length == 2) {
                String key = kv[0].trim();
                String val = kv[1].trim();
                if (key.startsWith("\"") && key.endsWith("\"")) {
                    key = key.substring(1, key.length()-1);
                }
                if (val.startsWith("\"") && val.endsWith("\"")) {
                    val = val.substring(1, val.length()-1);
                }
                map.put(key, val);
            }
        }
        return map;
    }
/**
 * Fetches a single row from Excel based on TestCaseID.
 * Returns a Map<header, value> or null if not found.
 */
public static Map<String, String> getRowByTestId(String excelPath, String sheetName, String testCaseId) throws Exception {
    List<Map<String, String>> allRows = readSheet(excelPath, sheetName);
    for (Map<String, String> row : allRows) {
        String id = row.getOrDefault("TestCaseID", "").trim();
        if (id.equalsIgnoreCase(testCaseId)) {
            return row;
        }
    }
    return null; // not found
}
}
