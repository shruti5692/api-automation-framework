package tests;

import org.framework.base.BaseApiClient;
import org.framework.config.ConfigManager;
import org.framework.model.AccountRecord;
import org.framework.utils.*;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * TestNG test - one test per TestCases Excel row (DataProvider).
 * Excel location: project root /TestData.xlsx (see EXCEL_PATH below).
 */
public class CustomerAccountTest {

    // Put TestData.xlsx at project root to allow writing back easily:
    private static final String EXCEL_PATH = System.getProperty("user.dir") + "/TestData.xlsx";
    private static final String AUTH_SHEET = "Auth";
    private static final String CASE_SHEET = "TestCases";

    // In-memory store of full responses for debugging
    private final List<String> fullResponses = Collections.synchronizedList(new ArrayList<>());

    @DataProvider(name = "cases")
    public Object[][] dataProvider() throws Exception {
        List<Map<String,String>> rows = ExcelUtils.readSheet(EXCEL_PATH, CASE_SHEET);
        Object[][] out = new Object[rows.size()][1];
        for (int i=0;i<rows.size();i++) out[i][0] = rows.get(i);
        return out;
    }

    @Test(dataProvider = "cases")
    public void validateTestCase(Map<String,String> row) throws Exception {
        String testCaseId = row.getOrDefault("TestCaseID", row.getOrDefault("testCaseID", ""));
        String customerCin = row.getOrDefault("CustomerIdentificationNumber", row.getOrDefault("CustomerIdentificationnumber", ""));
        String headersJson = row.getOrDefault("Headers", "");
        String expectedJson = row.getOrDefault("ExpectedOutput", "");

        if (testCaseId.isBlank()) throw new IllegalArgumentException("TestCaseID missing in Excel row");
        // get username from Auth sheet (use first row)
        List<Map<String,String>> auth = ExcelUtils.readSheet(EXCEL_PATH, AUTH_SHEET);
        if (auth.isEmpty()) throw new IllegalStateException("Auth sheet empty");
        String username = auth.get(0).getOrDefault("Username", auth.get(0).getOrDefault("username",""));
        if (username.isBlank()) throw new IllegalStateException("Username missing in Auth sheet");

        String result = "FAIL: unknown error";
        try {
            // parse headers JSON (Excel will have a JSON object string)
            Map<String,String> headers = parseHeaders(headersJson);

            // fetch jwt dynamically for this username
            String jwt = JwtFetcher.fetchJwt(username);
            headers.put("X-HSBC-E2E-Trust-Token", jwt);

            // sensitive data header built using config's sensitive.key and customer cin
            String sensitiveKey = ConfigManager.get("sensitive.key");
            String sensitiveJson = "[{\"key\":\"" + sensitiveKey + "\",\"value\":\"" + customerCin + "\"}]";
            headers.put("X-HSBC-Sensitive-Data", sensitiveJson);

            // ensure defaults if missing
            headers.putIfAbsent("Content-Type", "application/json");
            headers.putIfAbsent("Accept", "application/json");

            // build URL
            String base = ConfigManager.get("api.base.url");
            String path = ConfigManager.get("api.cust.account.path");
            // path expected e.g. /cb-rps-05/.../v1/cust
            String url = base + path + "/" + sensitiveKey + "/rel-acct";

            // call API
            BaseApiClient client = new BaseApiClient();
            Map<String,String> qp = Map.of("maxAccounts", "0004");
            BaseApiClient.ApiResponse resp = client.get(url, headers, qp);

            // store response
            fullResponses.add(resp.body);
            // write file
            Path outDir = Paths.get("target/apiResponses");
            Files.createDirectories(outDir);
            Files.writeString(outDir.resolve(testCaseId + ".json"), resp.body, StandardCharsets.UTF_8);

            if (resp.status != 200) {
                result = "FAIL: HTTP " + resp.status;
                ExcelUtils.writeResult(EXCEL_PATH, CASE_SHEET, testCaseId, result);
                Assert.fail(result);
            }

            // parse API records
            List<AccountRecord> apiRecords = JsonUtils.extractAccountRecordsFromApi(resp.body);
            // parse expected records from Excel
            List<AccountRecord> expectedRecords = JsonUtils.parseExpectedRecords(expectedJson);
            // fetch DB rows and convert
            List<Map<String,Object>> dbRows = DBUtils.fetchCudProdRelnByCin(customerCin);
            List<AccountRecord> dbRecords = JsonUtils.fromDbRows(dbRows);

            // compare sets (order independent)
            Set<AccountRecord> apiSet = new HashSet<>(apiRecords);
            Set<AccountRecord> expectedSet = new HashSet<>(expectedRecords);
            Set<AccountRecord> dbSet = new HashSet<>(dbRecords);

            boolean excelMatches = apiSet.equals(expectedSet);
            boolean dbMatches = apiSet.equals(dbSet);

            if (excelMatches && dbMatches) {
                result = "PASS";
            } else {
                // build descriptive diff
                Set<AccountRecord> onlyInApi = new HashSet<>(apiSet); onlyInApi.removeAll(dbSet); onlyInApi.removeAll(expectedSet);
                Set<AccountRecord> onlyInDb = new HashSet<>(dbSet); onlyInDb.removeAll(apiSet);
                Set<AccountRecord> onlyInExpected = new HashSet<>(expectedSet); onlyInExpected.removeAll(apiSet);

                StringBuilder sb = new StringBuilder();
                if (!excelMatches) sb.append("ExcelMismatch: onlyInExpected=").append(onlyInExpected).append("; ");
                if (!dbMatches) sb.append("DBMismatch: onlyInApi=").append(onlyInApi).append(", onlyInDb=").append(onlyInDb).append("; ");

                result = "FAIL: " + sb.toString();
                ExcelUtils.writeResult(EXCEL_PATH, CASE_SHEET, testCaseId, result);
                Assert.fail(result);
            }

            // success path -> write PASS
            ExcelUtils.writeResult(EXCEL_PATH, CASE_SHEET, testCaseId, result);

        } catch (AssertionError ae) {
            // already wrote result
            throw ae;
        } catch (Exception ex) {
            String msg = "FAIL: " + ex.getMessage();
            try { ExcelUtils.writeResult(EXCEL_PATH, CASE_SHEET, testCaseId, msg); } catch (Exception ignore){}
            throw new RuntimeException("TestCase " + testCaseId + " failed: " + ex.getMessage(), ex);
        }
    }

    private Map<String,String> parseHeaders(String json) {
        Map<String,String> map = new LinkedHashMap<>();
        if (json == null || json.isBlank()) return map;
        try {
            // use Jackson to parse into Map
            com.fasterxml.jackson.databind.ObjectMapper m = new com.fasterxml.jackson.databind.ObjectMapper();
            Map<String,Object> raw = m.readValue(json, Map.class);
            raw.forEach((k,v)-> map.put(String.valueOf(k), v == null ? "" : String.valueOf(v)));
        } catch (Exception e) {
            // fallback to naive parser (key:value pairs)
            String t = json.trim().replaceAll("[{}\"]", "");
            for (String kv : t.split(",")) {
                String[] parts = kv.split(":");
                if (parts.length == 2) map.put(parts[0].trim(), parts[1].trim());
            }
        }
        return map;
    }
}
