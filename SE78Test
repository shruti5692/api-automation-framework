import com.aventstack.extentreports.*;
import com.aventstack.extentreports.reporter.ExtentSparkReporter;
import okhttp3.*;
import org.json.JSONObject;
import org.testng.Assert;
import org.testng.Reporter;
import org.testng.annotations.*;
import utils.ApiValidationUtils;

import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class SE78Tests {

    private static ExtentReports extent;
    private ExtentTest test;
    private final OkHttpClient client = new OkHttpClient();

    // Only DB-relevant test cases
    private static final Set<String> DB_REQUIRED_TESTS = Set.of(
        "SE78_TC_01",
        "SE78_TC_02",
        "TC04_ClosedChargeID",
        "TC05_OpenChargeID"
    );

    @BeforeSuite
    public void beforeSuite() {
        ExtentSparkReporter spark = new ExtentSparkReporter("ExtentReport.html");
        extent = new ExtentReports();
        extent.attachReporter(spark);
    }

    @AfterSuite
    public void afterSuite() {
        extent.flush();
    }

    @BeforeMethod
    public void beforeMethod(Method method) {
        test = extent.createTest(method.getName());
    }

    @Test(dataProvider = "se78Data")
    public void callSecurityChargeApi(Map<String, String> row) throws Exception {

        String testId = row.getOrDefault("TestCaseID", "").trim();
        String chargeId = row.getOrDefault("ChargeID", "").trim();
        String headers = row.getOrDefault("Headers", "").trim();
        String expStatusStr = row.getOrDefault("ExpectedStatus", "").trim();
        String expectedFieldsJson = row.getOrDefault("ExpectedFields", "").trim();

        logBoth("=== Running SE78 test: " + testId + " (ChargeID='" + chargeId + "') ===");

        // ------------------ DB Fetch ------------------
        String dbOpenStatus = "UNKNOWN", dbFormStatus = "", dbCycCnt = "";
        Map<String, String> chargeData = null;
        boolean isDbRequired = DB_REQUIRED_TESTS.contains(testId);

        if (isDbRequired && !chargeId.isEmpty()) {
            logBoth("Step: Fetching DB data for ChargeID '" + chargeId + "'");
            try {
                chargeData = DbFetchHelper.fetchChargeData(chargeId);
                DbFetchHelper.logChargeData(chargeData);

                dbOpenStatus = chargeData.getOrDefault("OPEN_CLO_STA", "UNKNOWN");
                dbFormStatus = chargeData.getOrDefault("CHG_FORM_STA", "");
                dbCycCnt = chargeData.getOrDefault("ACYC_CNT", "");
            } catch (Exception e) {
                logBoth("[ERROR] Exception while fetching DB data: " + e.getMessage());
            }
        } else {
            logBoth("DB fetch skipped for this test case");
        }

        // ------------------ Prepare Headers & JWT ------------------
        String jwt = JwtFetcher.fetchIb2bJwt();
        Headers.Builder headerBuilder = new Headers.Builder();
        boolean trustTokenPresent = false;

        if (!headers.isBlank()) {
            JSONObject headerObj = new JSONObject(headers);
            for (Iterator<String> it = headerObj.keys(); it.hasNext(); ) {
                String k = it.next();
                String v = headerObj.optString(k, "");
                if (v.contains("{TRUST_TOKEN}")) v = v.replace("{TRUST_TOKEN}", jwt);
                if (k.equalsIgnoreCase("X-HSBC-E2E-Trust-Token") || k.equalsIgnoreCase("X-HSBC-TRUST-TOKEN"))
                    trustTokenPresent = true;
                headerBuilder.add(k, v);
                logBoth("Header added: " + k + "=" + v);
            }
        }
        if (!trustTokenPresent) {
            headerBuilder.add("X-HSBC-E2E-Trust-Token", jwt);
            logBoth("Header added: X-HSBC-E2E-Trust-Token=" + jwt);
        }

        // ------------------ API Call ------------------
        String safeCharge = chargeId.isEmpty() ? "%20" : chargeId;
        String url = "https://digitaldev-int-rbwm.systems.uk.hsbc" +
                     "/cb-rps-05/gb-hbeu-rps-mtg-prod-sec-chrg-enq-sct-internal-proxy" +
                     "/v1/securities/" + safeCharge + "/chargedtl";
        logBoth("Step: Calling SE78 API with URL: " + url);

        int status;
        String body;
        JSONObject responseJson;
        try (Response resp = client.newCall(
                new Request.Builder().url(url).headers(headerBuilder.build()).get().build()
        ).execute()) {
            status = resp.code();
            body = resp.body() == null ? "" : resp.body().string();
            responseJson = body.isEmpty() ? new JSONObject() : new JSONObject(body);
        }

        logBoth("HTTP Status: " + status);
        logBoth("Response Body (truncated): " + (body.length() > 500 ? body.substring(0, 500) + "..." : body));

        // ------------------ Status Validation ------------------
        if (!expStatusStr.isBlank()) {
            int expStatus = Integer.parseInt(expStatusStr);
            Assert.assertEquals(status, expStatus, "Unexpected HTTP status for test " + testId);
            logBoth("Expected HTTP status matched: " + expStatus);
        }

        // ------------------ Field-wise Validation ------------------
        boolean pass = true;
        if (isDbRequired) {
            logBoth("Step: Performing DB-driven field validation");
            Map<String, String> fieldsToValidate;

            if ("TC04_ClosedChargeID".equals(testId)) {
                fieldsToValidate = Map.of(
                        "gb-hbeu-rps-mtg-prod-sec-chrg-enq-v1-svcOperationResponse.errorResponse.errorResponseDetails.errorInfo[0].code",
                        "4310"
                );
            } else { // OpenChargeID
                fieldsToValidate = Map.of(
                        "gb-hbeu-rps-mtg-prod-sec-chrg-enq-v1-svcOperationResponse.responseMessage.responseBody.FormStatus",
                        dbFormStatus,
                        "gb-hbeu-rps-mtg-prod-sec-chrg-enq-v1-svcOperationResponse.responseMessage.responseBody.cyclicCount",
                        dbCycCnt,
                        "gb-hbeu-rps-mtg-prod-sec-chrg-enq-v1-svcOperationResponse.responseMessage.responseBody.errorCode",
                        "0"
                );
            }

            // Validate each field and log expected vs actual
            for (Map.Entry<String, String> entry : fieldsToValidate.entrySet()) {
                String path = entry.getKey();
                String expectedVal = entry.getValue();
                String actualVal = ApiValidationUtils.getValueFromJson(responseJson, path);

                String result = expectedVal.equals(actualVal) ? "PASS" : "FAIL";
                logBoth(String.format("Field validation -> %s | Expected: %s | Actual: %s | Result: %s",
                        path, expectedVal, actualVal, result));

                if (!result.equals("PASS")) pass = false;
            }
        } else if (!expectedFieldsJson.isBlank()) {
            logBoth("Step: Performing Excel-driven field validation");
            JSONObject expJson = new JSONObject(expectedFieldsJson);
            Map<String, String> excelFields = expJson.toMap().entrySet().stream()
                    .collect(java.util.stream.Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString()));
            pass = ApiValidationUtils.validateFields(excelFields, responseJson, test);
        }

        // ------------------ Test Result ------------------
        if (pass) logPass("Test passed for " + testId);
        else logFail("Field validation failed for " + testId);

        ExcelUtils.writeResult(EXCEL_PATH, SHEET_NAME, testId,
                pass ? "PASS" : "FAIL: Field validation failed");

        logBoth("=== End of Test: " + testId + " ===\n");
    }

    // ------------------------ Logging helpers ------------------------
    private void logBoth(String msg) {
        test.log(Status.INFO, msg);
        Reporter.log(msg, true);
    }

    private void logPass(String msg) {
        test.log(Status.PASS, msg);
        Reporter.log("[PASS] " + msg, true);
    }

    private void logFail(String msg) {
        test.log(Status.FAIL, msg);
        Reporter.log("[FAIL] " + msg, true);
    }
}
