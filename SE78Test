package tests;

import com.framework.utils.ExcelUtils;
import com.framework.utils.JwtFetcher;
import okhttp3.*;
import org.json.JSONArray;
import org.json.JSONObject;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class SE78Test {

    private static final String EXCEL_PATH = System.getProperty("user.dir") + "/TestData.xlsx";
    private static final String SHEET_NAME = "SE78";
    private final OkHttpClient client = new OkHttpClient();

    @DataProvider(name = "se78Data")
    public Object[][] se78Data() throws Exception {
        List<Map<String, String>> rows = ExcelUtils.readSheet(EXCEL_PATH, SHEET_NAME);
        Object[][] out = new Object[rows.size()][1];
        for (int i = 0; i < rows.size(); i++) out[i][0] = rows.get(i);
        return out;
    }

    @Test(dataProvider = "se78Data")
    public void callSecurityChargeApi(Map<String, String> row) throws Exception {
        String testId   = row.getOrDefault("TestCaseID", "").trim();
        String chargeId = row.getOrDefault("ChargeID", "").trim();
        String headers  = row.getOrDefault("Headers", "").trim();        // JSON text
        String expected = row.getOrDefault("ExpectedOutput", "").trim(); // JSON text (can be partial)

        if (testId.isEmpty()) throw new IllegalArgumentException("TestCaseID missing in Excel row");
        if (chargeId.isEmpty()) throw new IllegalArgumentException("ChargeID missing in Excel row");

        System.out.println("=== Running SE78 test: " + testId + " (ChargeID=" + chargeId + ") ===");

        // 1) Get JWT (iB2B translator)
        String jwt = JwtFetcher.fetchIb2bJwt(); // method must exist
        System.out.println("SE78Test - fetched JWT (truncated): " + (jwt == null ? "null" : jwt.substring(0, Math.min(64, jwt.length())) + "..."));

        // 2) Parse headers JSON from Excel and build OkHttp headers
        Headers.Builder headerBuilder = new Headers.Builder();
        boolean trustTokenPresent = false;

        if (!headers.isBlank()) {
            JSONObject headerObj = new JSONObject(headers);
            Iterator<String> keys = headerObj.keys();
            while (keys.hasNext()) {
                String key = keys.next();
                if (key == null) continue;
                String keyTrim = key.trim();
                if (keyTrim.isEmpty()) continue;

                String value = headerObj.optString(key, "");
                // replace placeholder if present
                if (value != null && value.contains("{TRUST_TOKEN}")) {
                    value = value.replace("{TRUST_TOKEN}", jwt);
                }

                if (keyTrim.equalsIgnoreCase("X-HSBC-E2E-Trust-Token") || keyTrim.equalsIgnoreCase("X-HSBC-TRUST-TOKEN")) {
                    trustTokenPresent = true;
                }

                headerBuilder.add(keyTrim, value == null ? "" : value);
            }
        }

        // Ensure trust token header exists and uses the fresh jwt
        if (!trustTokenPresent) {
            headerBuilder.add("X-HSBC-E2E-Trust-Token", jwt);
        }

        // 3) Build URL and request
        String url = "https://digitaldev-int-rbwm.systems.uk.hsbc" +
                "/cb-rps-05/gb-hbeu-rps-mtg-prod-sec-chrg-enq-sct-internal-proxy" +
                "/v1/securities/" + chargeId + "/chargedtl";

        Request request = new Request.Builder()
                .url(url)
                .headers(headerBuilder.build())
                .get()
                .build();

        // 4) Execute
        String responseBody;
        int status;
        try (Response response = client.newCall(request).execute()) {
            status = response.code();
            responseBody = response.body() == null ? "" : response.body().string();
        } catch (Exception e) {
            String res = "FAIL: Request error: " + e.getMessage();
            ExcelUtils.writeResult(EXCEL_PATH, SHEET_NAME, testId, res);
            throw e;
        }

        System.out.println("HTTP " + status + " | Response (truncated): " +
                (responseBody.length() > 500 ? responseBody.substring(0, 500) + "..." : responseBody));

        // 5) Basic HTTP check
        if (status != 200) {
            String res = "FAIL: HTTP " + status;
            ExcelUtils.writeResult(EXCEL_PATH, SHEET_NAME, testId, res);
            Assert.fail(res);
        }

        // 6) Validate response JSON contains expected JSON (partial or full)
        boolean pass = true;
        String failReason = "";

        if (expected != null && !expected.isBlank()) {
            try {
                JSONObject expectedJson = new JSONObject(expected);
                JSONObject actualJson = new JSONObject(responseBody);
                pass = jsonContains(expectedJson, actualJson);
                if (!pass) failReason = "Response JSON does not contain ExpectedOutput";
            } catch (Exception ex) {
                pass = false;
                failReason = "Validation error: " + ex.getMessage();
            }
        }

        // 7) Write result back to Excel and assert
        String result = pass ? "PASS" : "FAIL: " + (failReason.isEmpty() ? "mismatch" : failReason);
        ExcelUtils.writeResult(EXCEL_PATH, SHEET_NAME, testId, result);

        Assert.assertTrue(pass, "SE78 test failed for " + testId + " : " + failReason);
    }

    /**
     * Returns true if `actual` contains all fields/values of `expected`.
     * Supports nested objects and arrays.
     */
    private boolean jsonContains(Object expected, Object actual) {
        if (expected instanceof JSONObject) {
            if (!(actual instanceof JSONObject)) return false;
            JSONObject eObj = (JSONObject) expected;
            JSONObject aObj = (JSONObject) actual;
            for (String key : eObj.keySet()) {
                if (!aObj.has(key)) return false;
                Object eVal = eObj.get(key);
                Object aVal = aObj.get(key);
                if (!jsonContains(eVal, aVal)) return false;
            }
            return true;
        } else if (expected instanceof JSONArray) {
            if (!(actual instanceof JSONArray)) return false;
            JSONArray eArr = (JSONArray) expected;
            JSONArray aArr = (JSONArray) actual;
            // each expected element must be found inside actual array (order independent)
            for (int i = 0; i < eArr.length(); i++) {
                Object eEl = eArr.get(i);
                boolean found = false;
                for (int j = 0; j < aArr.length(); j++) {
                    if (jsonContains(eEl, aArr.get(j))) {
                        found = true;
                        break;
                    }
                }
                if (!found) return false;
            }
            return true;
        } else {
            // primitive compare as strings (trimmed)
            String e = expected == null ? "" : expected.toString().trim();
            String a = actual == null ? "" : actual.toString().trim();
            return e.equals(a);
        }
    }
}
