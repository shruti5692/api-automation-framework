// Put this method into your SE78 test class (adjust imports if needed)
@Test(dataProvider = "se78Data")
public void callSecurityChargeApi(Map<String, String> row) throws Exception {
    long startTime = System.currentTimeMillis();

    // ---------------- read input from Excel row ----------------
    String testId = row.getOrDefault("TestCaseID", "").trim();
    String chargeId = row.getOrDefault("ChargeID", "").trim();
    String headersJson = row.getOrDefault("Headers", "").trim();
    String expStatusStr = row.getOrDefault("ExpectedStatus", "").trim();
    String expectedFieldsJson = row.getOrDefault("ExpectedFields", "").trim();

    // quick logs
    safeLog("=== START TEST: " + testId + " (ChargeID=" + chargeId + ") ===");
    safeLog("ExpectedStatus cell: \"" + expStatusStr + "\"");
    safeLog("ExpectedFields cell: " + (expectedFieldsJson.isBlank() ? "<empty>" : expectedFieldsJson));
    safeLog("Headers cell: " + (headersJson.isBlank() ? "<empty>" : headersJson));

    // ----------------- DB fetch (if required) -----------------
    List<Map<String, String>> dbData = new ArrayList<>();
    boolean isDbRequired = DB_REQUIRED_TESTS.contains(testId); // keep your existing set
    if (isDbRequired && !chargeId.isEmpty()) {
        safeLog("[DB] Fetching DB data for ChargeID: " + chargeId);
        try {
            dbData = fetchData(CHARGE_QUERY, chargeId);
            safeLog("[DB] Raw dbData: " + dbData);
        } catch (Exception e) {
            safeLog("[DB][ERROR] fetchData failed: " + e.getMessage());
        }
    } else {
        safeLog("[DB] Fetch skipped for this test case");
    }

    // ----------------- Prepare headers -----------------
    safeLog("Preparing headers...");
    String jwt = JwtFetcher.fetchIb2bJwt(); // keep your existing JWT fetcher

    Headers.Builder hb = new Headers.Builder();
    // Add static headers you had
    hb.add("Content-Type", "application/json");
    hb.add("X-HSBC-Channel-Id", "OHB");
    hb.add("X-HSBC-Request-Correlation-Id", "123498");
    hb.add("X-HSBC-E2E-Trust-Token", jwt);
    hb.add("X-HSBC-Src-UserAgent", "Apache-HttpClient/4.5.6 (Java/1.8.0_112)");
    hb.add("X-HSBC-User-Id", "43998226");
    // Merge dynamic headers from Excel cell if present
    if (!headersJson.isBlank()) {
        try {
            Map<String, String> excelHeaders = JsonUtils.jsonToFlatMap(headersJson);
            for (Map.Entry<String, String> e : excelHeaders.entrySet()) {
                hb.add(e.getKey(), e.getValue());
            }
            safeLog("Merged headers from Excel: " + excelHeaders.keySet());
        } catch (Exception ex) {
            safeLog("[WARN] Could not parse Headers JSON from Excel: " + ex.getMessage());
        }
    }
    Headers headersObj = hb.build();
    headersObj.names().forEach(n -> safeLog("Header: " + n + " = " + headersObj.get(n)));

    // ----------------- Build URL & call API -----------------
    String safeCharge = chargeId.isEmpty() ? "%20" : chargeId;
    String baseUrl = ConfigManager.get("se78.url"); // your config
    String url = baseUrl.endsWith("/") ? baseUrl + safeCharge + "/chargedtl" : baseUrl + "/" + safeCharge + "/chargedtl";
    safeLog("Calling URL: " + url);

    OkHttpClient client = new OkHttpClient();
    String apiBody;
    int status;
    Request request = new Request.Builder().url(url).headers(headersObj).get().build();
    try (Response resp = client.newCall(request).execute()) {
        status = resp.code();
        ResponseBody rb = resp.body();
        apiBody = rb != null ? rb.string() : "";
    } catch (Exception e) {
        // network/IO error
        safeLog("[ERROR] HTTP call failed: " + e.getMessage());
        throw e;
    }

    safeLog("HTTP Status: " + status);
    safeLog("Response Body (truncated): " + (apiBody == null ? "<null>" : apiBody.length() > 800 ? apiBody.substring(0, 800) + "..." : apiBody));

    // ----------------- Status validation -----------------
    if (!expStatusStr.isBlank()) {
        int expectedStatus = Integer.parseInt(expStatusStr);
        safeLog("Checking expected HTTP status: " + expectedStatus);
        Assert.assertEquals(status, expectedStatus, "Unexpected HTTP status for test " + testId);
        safeLog("Expected HTTP status matched: " + expectedStatus);
    }

    // ----------------- Convert API JSON to flattened structures -----------------
    List<Map<String, String>> apiDataList = Collections.emptyList();
    Map<String, String> apiFlatMap = new LinkedHashMap<>();
    try {
        apiDataList = JsonUtils.jsonToListOfMaps(apiBody); // each map is a flattened representation of a record/object
        // build one merged flat map for key-searching (prefer first occurrence)
        for (Map<String, String> m : apiDataList) {
            for (Map.Entry<String, String> e : m.entrySet()) {
                apiFlatMap.putIfAbsent(e.getKey(), e.getValue());
            }
        }
    } catch (Exception e) {
        safeLog("[WARN] JsonUtils parsing failed: " + e.getMessage());
    }

    safeLog("API Data List: " + apiDataList);
    safeLog("Flattened API keys available: " + apiFlatMap.keySet());

    // ----------------- FIELD-WISE VALIDATION -----------------
    boolean pass = true;
    StringBuilder failReasons = new StringBuilder();

    // small normalizer: remove array indices and non-alphanum chars, lowercase
    java.util.function.Function<String, String> normalize = s -> {
        if (s == null) return "";
        return s.replaceAll("\\[\\d+\\]", "")           // remove [0], [1], ...
                .replaceAll("[^A-Za-z0-9]", "")         // remove punctuation/dots/underscores
                .toLowerCase()
                .trim();
    };

    // 1) DB-driven validation (if DB row exists)
    if (isDbRequired && dbData != null && !dbData.isEmpty()) {
        safeLog("Step: Performing DB-driven field validation (using first DB row)");
        Map<String, String> dbRow = dbData.get(0);
        safeLog("DB row keys: " + dbRow.keySet());

        for (Map.Entry<String, String> dbEntry : dbRow.entrySet()) {
            String dbField = dbEntry.getKey();                 // e.g., OPEN_CLO_STA, CHG_ID, CYC_CNT
            String expected = dbEntry.getValue();

            // find first apiFlatMap entry whose normalized key ends with normalized dbField
            Optional<Map.Entry<String, String>> match = apiFlatMap.entrySet().stream()
                    .filter(e -> normalize.apply(e.getKey()).endsWith(normalize.apply(dbField)))
                    .findFirst();

            String actual = match.map(Map.Entry::getValue).orElse(null);

            // LOG expected vs actual clearly (both system and logBoth)
            String logLine = String.format("DB Validation -> Field: %-18s | Expected: %-12s | Actual: %-12s",
                    dbField, expected == null ? "null" : expected, actual == null ? "null" : actual);
            safeLog(logLine);

            if (!equalsIgnoreCaseTrim(expected, actual)) {
                pass = false;
                failReasons.append(String.format("\nField '%s' mismatch. Expected: %s, Actual: %s", dbField, expected, actual));
            }
        }
        safeLog("DB validation finished");
    }
    // 2) Excel-driven validation when ExpectedFields provided and DB not used
    else if (!expectedFieldsJson.trim().isEmpty()) {
        safeLog("Step: Performing Excel-driven field validation using ExpectedFields");
        Map<String, String> expectedFields;
        try {
            expectedFields = JsonUtils.jsonToFlatMap(expectedFieldsJson);
        } catch (Exception e) {
            expectedFields = new HashMap<>();
            safeLog("[WARN] Failed to parse ExpectedFields JSON: " + e.getMessage());
        }
        safeLog("Expected fields from Excel: " + expectedFields.keySet());

        for (Map.Entry<String, String> expectedEntry : expectedFields.entrySet()) {
            String shortField = expectedEntry.getKey().trim();   // e.g., applicationId or correlationId or eimId
            String expectedValue = expectedEntry.getValue();

            Optional<Map.Entry<String, String>> match = apiFlatMap.entrySet().stream()
                    .filter(e -> normalize.apply(e.getKey()).endsWith(normalize.apply(shortField)))
                    .findFirst();

            String actualValue = match.map(Map.Entry::getValue).orElse(null);

            String logLine = String.format("Excel Validation -> Field: %-18s | Expected: %-12s | Actual: %-12s",
                    shortField, expectedValue == null ? "null" : expectedValue, actualValue == null ? "null" : actualValue);
            safeLog(logLine);

            if (!equalsIgnoreCaseTrim(expectedValue, actualValue)) {
                pass = false;
                failReasons.append(String.format("\nField '%s' mismatch. Expected: %s, Actual: %s", shortField, expectedValue, actualValue));
            }
        }
        safeLog("Excel validation finished");
    } else {
        safeLog("No DB data and no ExpectedFields â€” skipping field-wise validation");
    }

    // ----------------- Report result, write to Excel, and finish -----------------
    long durationSec = (System.currentTimeMillis() - startTime) / 1000;
    if (pass) {
        safeLog("[PASS] Test passed for testId " + testId + " in " + durationSec + " sec");
        // keep your existing Excel write if you do that; example:
        ExcelUtils.writeResultWithDuration(EXCEL_PATH, SHEET_NAME, testId, "PASS", durationSec);
    } else {
        safeLog("[FAIL] Field validation failed for testId " + testId + " Reason: " + failReasons);
        ExcelUtils.writeResultWithDuration(EXCEL_PATH, SHEET_NAME, testId, "FAIL: " + failReasons.toString(), durationSec);
        Assert.fail(failReasons.toString());
    }

    safeLog("=== END TEST: " + testId + " (Duration: " + durationSec + "s) ===");
}

/* ----------------- small helpers used above ----------------- */

// normalize + compare helper
private static boolean equalsIgnoreCaseTrim(String a, String b) {
    if (a == null && b == null) return true;
    if (a == null || b == null) return false;
    return a.trim().equalsIgnoreCase(b.trim());
}

// safe logging wrapper (calls your logBoth if present, also prints to stdout so nothing is suppressed)
private static void safeLog(String msg) {
    try {
        // if you have logBoth in your framework, it will be called; otherwise ignore
        try {
            // try to call your logger if available
            Class<?> loggerCls = Class.forName("org.framework.utils.LoggerUtils");
            try {
                java.lang.reflect.Method m = loggerCls.getMethod("logBoth", String.class);
                m.invoke(null, msg);
            } catch (NoSuchMethodException ignore) {
                System.out.println(msg);
            }
        } catch (ClassNotFoundException cnfe) {
            // fallback to stdout
            System.out.println(msg);
        }
    } catch (Throwable t) {
        // ultimate fallback
        System.out.println(msg);
    }
}
