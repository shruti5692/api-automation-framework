@Test(dataProvider = "se78Data")
public void callSecurityChargeApi(Map<String, String> row) throws Exception {

    // ------------------- START TIMER ------------------- //
    long startTime = System.currentTimeMillis();

    String testId       = row.getOrDefault("TestCaseID", "").trim();
    String chargeId     = row.getOrDefault("ChargeID", "").trim();
    String headers      = row.getOrDefault("Headers", "").trim();
    String expStatusStr = row.getOrDefault("ExpectedStatus", "").trim();
    String expectedFieldsJson = row.getOrDefault("ExpectedFields", "").trim();

    int expectedStatus = expStatusStr.isEmpty() ? 200 : Integer.parseInt(expStatusStr);

    logBoth("------------------------------------------------------------");
    logBoth("Starting test case: " + testId);
    logBoth("Charge ID: " + chargeId);
    logBoth("Expected Status: " + expectedStatus);

    // ------------------- BUILD API REQUEST ------------------- //
    String url = "https://digitaldev-int-rbwm.systems.uk.hsbc/cb-rps-05/qb-hbeu-rps-sta-prod-sec-chrg-eng-sat-intermd";
    logBoth("API URL: " + url);

    HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
    conn.setRequestMethod("POST");
    conn.setRequestProperty("Content-Type", "application/json");

    // Apply dynamic headers from Excel
    if (!headers.isEmpty()) {
        Map<String, String> headerMap = JsonUtils.jsonToFlatMap(headers);
        for (Map.Entry<String, String> entry : headerMap.entrySet()) {
            conn.setRequestProperty(entry.getKey(), entry.getValue());
        }
    }

    conn.setDoOutput(true);

    // Create request body
    String requestBody = String.format(
            "{\"sensitiveKey\":[{\"key\":\"84d89877f0d4041efb6bf91a16f0248f2fd573e6af05c19f96bedb9f882f7884\",\"value\":\"%s\"}]}",
            chargeId);
    logBoth("Request Body: " + requestBody);

    try (OutputStream os = conn.getOutputStream()) {
        os.write(requestBody.getBytes(StandardCharsets.UTF_8));
    }

    // ------------------- API RESPONSE ------------------- //
    int actualStatus = conn.getResponseCode();
    String response = new String(conn.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
    logBoth("HTTP Status: " + actualStatus);
    logBoth("Response Body: " + response);

    boolean pass = (expectedStatus == actualStatus);
    String failReason = "";

    // ------------------- VALIDATION LOGIC ------------------- //
    List<Map<String, String>> apiDataList = JsonUtils.jsonToListOfMaps(response);
    List<Map<String, String>> dbDataList = DbFetchHelper.fetchDbData(chargeId); // You already have this method

    boolean hasDbData = dbDataList != null && !dbDataList.isEmpty();
    boolean hasExpectedFields = expectedFieldsJson != null && !expectedFieldsJson.isBlank();

    if (hasDbData) {
        logBoth("Step: Performing field-wise validation using DB data");

        for (Map<String, String> dbRecord : dbDataList) {
            for (Map.Entry<String, String> dbEntry : dbRecord.entrySet()) {
                String fieldName = dbEntry.getKey();
                String expectedValue = dbEntry.getValue();

                // find matching API key (case-insensitive)
                String actualValue = apiDataList.stream()
                        .flatMap(apiMap -> apiMap.entrySet().stream())
                        .filter(e -> e.getKey().equalsIgnoreCase(fieldName)
                                || e.getKey().toLowerCase().endsWith(fieldName.toLowerCase()))
                        .map(Map.Entry::getValue)
                        .findFirst()
                        .orElse(null);

                if (!Objects.equals(expectedValue, actualValue)) {
                    pass = false;
                    failReason += String.format("Field '%s' mismatch. Expected: %s, Actual: %s%n",
                            fieldName, expectedValue, actualValue);
                    logBoth(failReason);
                }
            }
        }
    }
    else if (hasExpectedFields) {
        logBoth("Step: Performing dynamic field-wise validation using Excel ExpectedFields");

        Map<String, String> expectedFields = JsonUtils.jsonToFlatMap(expectedFieldsJson);

        for (Map<String, String> apiRecord : apiDataList) {
            for (Map.Entry<String, String> expectedEntry : expectedFields.entrySet()) {
                String fieldName = expectedEntry.getKey();
                String expectedValue = expectedEntry.getValue();

                // find matching key from API (case-insensitive)
                String actualValue = apiRecord.entrySet().stream()
                        .filter(e -> e.getKey().equalsIgnoreCase(fieldName)
                                || e.getKey().toLowerCase().endsWith(fieldName.toLowerCase()))
                        .map(Map.Entry::getValue)
                        .findFirst()
                        .orElse(null);

                if (!Objects.equals(expectedValue, actualValue)) {
                    pass = false;
                    failReason += String.format("Field '%s' mismatch. Expected: %s, Actual: %s%n",
                            fieldName, expectedValue, actualValue);
                    logBoth(failReason);
                }
            }
        }
    } else {
        logBoth("No DB data or ExpectedFields found â€” skipping field-wise validation");
    }

    // ------------------- RESULT SECTION ------------------- //
    if (pass) {
        logBoth("[PASS] Test Case: " + testId + " passed successfully!");
    } else {
        logBoth("[FAIL] Field validation failed for testId " + testId + " Reason: " + failReason);
    }

    long endTime = System.currentTimeMillis();
    logBoth("Execution time: " + (endTime - startTime) + " ms");
    logBoth("------------------------------------------------------------");
}
