write ApiUtils in such a way that it actually becomes utility so that no matter what the api is we can use that utility. ApiUtils is under main folder . so my goal is user should not touch anything undermain folder. TestExecutor n PY22Tests is under test folder. I want to use methods like logBoth, logpass logfail, before suite, after suite, before method

Here’s how to refactor `ApiUtils` so it is a pure utility class, easy to use for **any** API call (GET/POST/PUT/DELETE/ANY), generic and flexible, placed under the main folder, and not coupled to reporting or TestNG. All logging and reporting will be handled in the test layer (your test code), which uses utility methods like `logBoth`, `logPass`, `logFail` as needed.

***

### ApiUtils.java (UTILITY, NO TEST LOGIC)

```java
package com.framework.utils;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.*;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Pure utility class for making any type of API request.
 * Users should NOT modify this utility or add anything test- or report-specific here.
 */
public class ApiUtils {

    private static final ObjectMapper MAPPER = new ObjectMapper();

    /**
     * Generic API call utility.
     * @param urlOrConfigKey - If you want, you can provide a URL, or for your config system, a config key.
     * @param headers - Headers for the request (can be empty map if not needed).
     * @param body - Request body string (null or empty for GET/DELETE)
     * @param method - Method type: GET, POST, PUT, DELETE, etc.
     * @return fully parsed response (statusCode, headers, body raw, and body as Map if JSON)
     * @throws Exception on IO failure
     */
    public static ApiResponse callApi(
            String urlOrConfigKey,
            Map<String, String> headers,
            String body,
            String method
    ) throws Exception {
        String apiUrl = urlOrConfigKey;
        if(apiUrl.startsWith("http")) {
            // use as-is
        } else {
            // try config
            apiUrl = ConfigReader.get(urlOrConfigKey);
        }
        if (apiUrl == null || apiUrl.isBlank())
            throw new RuntimeException("Missing API URL for: " + urlOrConfigKey);

        URL url = new URL(apiUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod(method);
        conn.setConnectTimeout(10000);
        conn.setReadTimeout(15000);

        // Add headers
        if(headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                conn.setRequestProperty(entry.getKey(), entry.getValue());
            }
        }

        // Write body for POST/PUT/PATCH
        if ((method.equalsIgnoreCase("POST")
                || method.equalsIgnoreCase("PUT")
                || method.equalsIgnoreCase("PATCH"))
            && body != null && !body.isEmpty()) {
            conn.setDoOutput(true);
            conn.setRequestProperty("Content-Type", "application/json");
            try (OutputStream os = conn.getOutputStream()) {
                os.write(body.getBytes(StandardCharsets.UTF_8));
                os.flush();
            }
        }

        // Read response code, headers & body
        int statusCode = conn.getResponseCode();
        Map<String, List<String>> headerFields = conn.getHeaderFields();

        BufferedReader reader = new BufferedReader(new InputStreamReader(
                statusCode < 400 ? conn.getInputStream() : conn.getErrorStream()
        ));

        StringBuilder resp = new StringBuilder();
        String l;
        while ((l = reader.readLine()) != null) resp.append(l);
        reader.close();

        // Try to parse response body (as JSON or plain)
        String responseBodyRaw = resp.toString();
        Map<String, Object> responseBodyMap = new HashMap<>();
        try {
            responseBodyMap = MAPPER.readValue(responseBodyRaw, Map.class);
        } catch (Exception ignore) {}

        return new ApiResponse(apiUrl, statusCode, headerFields, responseBodyRaw, responseBodyMap);
    }

    // Represents a generic API response
    public static class ApiResponse {
        public final String url;
        public final int statusCode;
        public final Map<String, List<String>> headers;
        public final String bodyRaw;
        public final Map<String, Object> bodyMap;

        public ApiResponse(String url, int statusCode, Map<String, List<String>> headers,
                           String bodyRaw, Map<String, Object> bodyMap) {
            this.url = url;
            this.statusCode = statusCode;
            this.headers = headers;
            this.bodyRaw = bodyRaw;
            this.bodyMap = bodyMap;
        }
    }
}
```
This utility is **pure**, and can be called for **any API** from your test code, no matter the API shape or parameters[1].

***

### Example Reporting in Test Layer (TestExecutor/PY22Tests)

You write all reporting and test logic in the test level (using ExtentReports, logPass, logFail etc.), for example:

```java
@BeforeSuite
public void setupReport() {
    ExtentSparkReporter spark = new ExtentSparkReporter("test-output/ExtentSpark.html");
    extent = new ExtentReports();
    extent.attachReporter(spark);
}

@BeforeMethod
public void beforeMethod(Method method) {
    test = extent.createTest(method.getName());
    logBoth("Starting test method: " + method.getName());
}

@Test
public void exampleTest() {
    Map<String, String> headers = new HashMap<>();
    headers.put("Authorization", "Bearer tokenvalue");

    ApiUtils.ApiResponse response = ApiUtils.callApi(
        "https://jsonplaceholder.typicode.com/posts/1",
        headers, null, "GET"
    );

    logBoth("Status code: " + response.statusCode);
    logBoth("Body: " + response.bodyRaw);

    if (response.statusCode == 200) {
        logPass("Received 200 OK");
    } else {
        logFail("API returned not 200");
    }
}

@AfterMethod
public void afterMethod(ITestResult result) {
    if (result.isSuccess()) {
        logPass("Test Passed");
    } else {
        logFail("Test Failed: " + result.getThrowable());
    }
    extent.flush();
}

@AfterSuite
public void tearDownReport() {
    extent.flush();
}

// Logging helpers for test layer
public void logBoth(String msg) {
    test.info(msg);
}
public void logPass(String msg) {
    test.pass(msg);
}
public void logFail(String msg) {
    test.fail(msg);
}
```
With this architecture:
- `ApiUtils` is reusable, API-agnostic, and safe for all teams.
- All test data, validation, and reporting are managed at the test layer, where you use log methods, suites, and other hooks.
- You never touch main/util code for reporting or test flow—**all is in the test layer** as you want.

This separation makes your utilities robust, reusable, and standard across all your testing projects[1].

Citations:
[1] ApiUtils.txt https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/88928485/504c90e4-ac15-44f9-9602-eeb2c42dff84/ApiUtils.txt
