give me updated code for TestExecutor n PY22Tests with all these logging methods

Below are the updated versions of your `TestExecutor` and `PY22Tests` classes integrating the requested logging methods such as `logBoth`, `logPass`, `logFail`, and lifecycle methods `beforeSuite`, `afterSuite`, and `beforeMethod`. The reporting and logging are centralized, and logging methods can be customized to use ExtentSparkReporter as defined in a shared report manager or base test class.

***

### TestExecutor.java

```java
package com.framework.core;

import com.framework.utils.*;
import com.framework.utils.ApiUtils.ApiResponse;
import org.testng.annotations.*;

import java.util.Map;

public class TestExecutor {

    public static ExtentReports extent;
    public static ExtentTest test;

    @BeforeSuite
    public void beforeSuite() {
        ExtentSparkReporter spark = new ExtentSparkReporter("test-output/ExtentSpark.html");
        extent = new ExtentReports();
        extent.attachReporter(spark);
        logBoth("=== Test Suite Started ===");
    }

    @AfterSuite
    public void afterSuite() {
        logBoth("=== Test Suite Finished ===");
        extent.flush();
    }

    @BeforeMethod
    public void beforeMethod(Method method) {
        test = extent.createTest(method.getName());
        logBoth("Starting test method: " + method.getName());
    }

    public void logBoth(String message) {
        System.out.println(message);
        if (test != null) test.info(message);
    }

    public void logPass(String message) {
        System.out.println("PASS: " + message);
        if (test != null) test.pass(message);
    }

    public void logFail(String message) {
        System.err.println("FAIL: " + message);
        if (test != null) test.fail(message);
    }

    public static void runCase(Map<String, String> row) throws Exception {
        String testId = row.getOrDefault("TestCaseID", "").trim();
        test = extent.createTest("TestCase: " + testId);

        String branchNum = row.getOrDefault("Branch number", "").trim();
        String accNum = row.getOrDefault("AccountNumber", "").trim();
        String expectedStatus = row.getOrDefault("ExpectedStatus", "").trim();
        String expectedResponseCode = row.getOrDefault("Response code", "").trim();

        String prodId = "";
        if (!branchNum.isEmpty() && !accNum.isEmpty()) prodId = branchNum + accNum;
        else if (!branchNum.isEmpty()) prodId = branchNum;
        else if (!accNum.isEmpty()) prodId = accNum;

        test.info("TestCaseID: " + testId);
        test.info("PROD_ID constructed: " + prodId);

        long start = System.currentTimeMillis();

        String jwt = JwtFetcher.generateToken();
        Map<String, String> headers = HeaderUtils.buildHeaders(jwt, prodId);
        test.info("JWT generated. Headers: " + headers);

        ApiResponse response = ApiUtils.callApi("py22.api.url", headers, null, "GET");
        test.info("API call made, got response: " + response.bodyRaw);

        int statusCode = response.statusCode;
        Map<String, Object> flatResponse = response.bodyMap;

        String actualResponseCode = flatResponse.getOrDefault("responseCode", "").toString();
        String actualErrorCode = flatResponse.getOrDefault("errorCode", "").toString();

        test.info("HTTP Status: " + statusCode);
        test.info("Actual ResponseCode: " + actualResponseCode);
        test.info("Actual ErrorCode: " + actualErrorCode);

        String result;
        if (statusCode == 200) {
            result = expectedResponseCode.equals(actualResponseCode) ? "PASS" : "FAIL";
            test.info("Validation: comparing expectedResponseCode [" + expectedResponseCode + "] with actualResponseCode [" + actualResponseCode + "]");
        } else {
            result = expectedResponseCode.equals(actualErrorCode) ? "PASS" : "FAIL";
            test.info("Validation: comparing expectedResponseCode [" + expectedResponseCode + "] with actualErrorCode [" + actualErrorCode + "]");
        }

        long durationSec = (System.currentTimeMillis() - start) / 1000;
        test.info("Test Duration: " + durationSec + " seconds");
        test.info("Result: " + result);

        if ("PASS".equals(result)) {
            test.pass("Test Passed");
        } else {
            test.fail("Test Failed");
        }

        ExcelUtils.writeResultWithDuration("src/test/resources/testdata.xlsx", "PY22", testId, result, durationSec);

        extent.flush();
    }
}
```

***

### PY22Tests.java

```java
package com.framework.tests;

import com.framework.core.TestExecutor;
import com.framework.utils.ExcelUtils;
import org.testng.annotations.*;

import java.util.Map;

public class PY22Tests {

    private static final String EXCEL_PATH = "src/test/resources/testdata.xlsx";
    private static final String SHEET = "PY22";

    @BeforeSuite
    public void beforeSuite() {
        TestExecutor.beforeSuite();
    }

    @AfterSuite
    public void afterSuite() {
        TestExecutor.afterSuite();
    }

    @BeforeMethod
    public void beforeMethod(java.lang.reflect.Method method) {
        TestExecutor.beforeMethod(method);
    }

    @Test(description = "TC01 - Valid PROD_ID")
    public void TC01_Valid_PROD_ID() throws Exception {
        TestExecutor.test.info("Starting test: TC01_Valid_PROD_ID");
        Map<String, String> data = ExcelUtils.getRowByTestId(EXCEL_PATH, SHEET, "TC01_SC01_PY22_Valid_PROD_ID");
        TestExecutor.runCase(data);
        TestExecutor.test.info("Ending test: TC01_Valid_PROD_ID");
    }

    @Test(description = "TC02 - Mandatory Field Validation (Branch number)")
    public void TC02_MandatoryField_Validation_BranchNumber() throws Exception {
        TestExecutor.test.info("Starting test: TC02_MandatoryField_Validation_BranchNumber");
        Map<String, String> data = ExcelUtils.getRowByTestId(EXCEL_PATH, SHEET, "TC02_SC01_PY22_MandatoryField_Validation_BranchNumber");
        TestExecutor.runCase(data);
        TestExecutor.test.info("Ending test: TC02_MandatoryField_Validation_BranchNumber");
    }

    @Test(description = "TC03 - Mandatory Field Validation (Account number)")
    public void TC03_MandatoryField_Validation_AccountNumber() throws Exception {
        TestExecutor.test.info("Starting test: TC03_MandatoryField_Validation_AccountNumber");
        Map<String, String> data = ExcelUtils.getRowByTestId(EXCEL_PATH, SHEET, "TC03_SC01_PY22_MandatoryField_Validation_AccountNumber");
        TestExecutor.runCase(data);
        TestExecutor.test.info("Ending test: TC03_MandatoryField_Validation_AccountNumber");
    }
}
```

***

These implementations centralize and unify your logging using ExtentReports and provide your requested lifecycle methods. All test flow and logging are handled in the test classes or TestExecutor, so your `ApiUtils` remains untouched and purely utility-focused.

You can extend this pattern with additional tests and logging helpers as needed.

