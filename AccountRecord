package org.framework.model;

import java.util.Objects;

/**
 * POJO representing the 4 fields we assert.
 * Normalizes accountNumber and sortCode by trimming and removing leading zeros.
 */
public class AccountRecord {
    public final String productCode;
    public final String accountNumber;
    public final String sortCode;
    public final String accountIn;

    public AccountRecord(String productCode, String accountNumber, String sortCode, String accountIn) {
        this.productCode = normalize(productCode).toUpperCase();
        this.accountNumber = normalizeAccount(accountNumber);
        this.sortCode = normalizeSort(sortCode);
        this.accountIn = normalize(accountIn).toUpperCase();
    }

    private static String normalize(String s) { return s == null ? "" : s.trim(); }

    // remove leading zeros for comparison
    private static String normalizeAccount(String s) {
        if (s == null) return "";
        String t = s.trim();
        return t.replaceFirst("^0+(?!$)", "");
    }

    private static String normalizeSort(String s) {
        if (s == null) return "";
        return s.trim().replaceFirst("^0+(?!$)", "");
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof AccountRecord)) return false;
        AccountRecord other = (AccountRecord) o;
        return productCode.equals(other.productCode)
                && accountNumber.equals(other.accountNumber)
                && sortCode.equals(other.sortCode)
                && accountIn.equals(other.accountIn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(productCode, accountNumber, sortCode, accountIn);
    }

    @Override
    public String toString() {
        return "AccountRecord{" +
                "productCode='" + productCode + '\'' +
                ", accountNumber='" + accountNumber + '\'' +
                ", sortCode='" + sortCode + '\'' +
                ", accountIn='" + accountIn + '\'' +
                '}';
    }
}


SELECT
    m.PROD_REF,
    m.NEXT_PYMT_DUE_DT,
    m.MNDT_STA,
    b.BR_NO,
    b.PROC_GRP_NO,
    a.PROD_COD,
    i.BUS_PERS_IND
FROM DDU_PYMT_RQST_MNDT m
JOIN PLM_BR_PROC_GRP b
    ON b.BR_NO = TO_NUMBER(SUBSTR(m.PROD_REF, 1, 6))
JOIN PLM_ACCOUNT a
    ON a.BR_ACCT_NO = m.PROD_REF
JOIN BUD_PROD_ITEM i
    ON i.PROD_ITEM_COD = a.PROD_COD
WHERE m.MNDT_STA = 'L'
  AND m.NEXT_PYMT_DUE_DT > SYSDATE
  AND LENGTH(m.PROD_REF) = 14;


WITH MANDATE_FILT AS (
    SELECT PROD_REF, NEXT_PYMT_DUE_DT
    FROM DDU_PYMT_RQST_MNDT
    WHERE MNDT_STA = 'L'
      AND NEXT_PYMT_DUE_DT > CURRENT DATE
)
SELECT
    m.PROD_REF,
    m.NEXT_PYMT_DUE_DT,
    a.PROD_COD,
    i.BUS_PERS_IND
FROM MANDATE_FILT m
JOIN PLM_ACCOUNT a
    ON a.BR_ACCT_NO = m.PROD_REF
JOIN BUD_PROD_ITEM i
    ON i.PROD_ITEM_COD = a.PROD_COD
FETCH FIRST 50 ROWS ONLY;

SELECT DISTINCT
       b.BR_NO,
       b.ACTG_ENTY,
       b.ACTG_ENTY_DES
FROM PLM_BR_PROC_GRP b
WHERE EXISTS (
    SELECT 1
    FROM DDU_PYMT_RQST_MNDT m
    WHERE m.MNDT_STA = 'L'
      AND LENGTH(m.PROD_REF) >= 6
      AND b.BR_NO = INTEGER(SUBSTR(m.PROD_REF, 1, 6))
);
SELECT
    lm.BR_ACCT_NO,
    pg.ACTG_ENTY,
    pg.ACTV_ENTY_DES,
    acc.PROD_COD,
    bpi.BUS_PERS_IND
FROM PLM_LOAN_MATURITY lm
JOIN PLM_BR_PROC_GRP pg
    ON pg.BR_NO = SUBSTR(lm.BR_ACCT_NO, 1, 6)
JOIN PLM_ACCOUNT acc
    ON acc.BR_ACCT_NO = lm.BR_ACCT_NO
JOIN BUD_PROD_ITEM bpi
    ON bpi.PROD_ITEM_COD = acc.PROD_COD;SELECT
    lm.BR_ACCT_NO,
    pg.ACTG_ENTY,
    pg.ACTV_ENTY_DES,
    acc.PROD_COD,
    bpi.BUS_PERS_IND
FROM PLM_LOAN_MATURITY lm
JOIN PLM_BR_PROC_GRP pg
    ON pg.BR_NO = SUBSTR(lm.BR_ACCT_NO, 1, 6)
JOIN PLM_ACCOUNT acc
    ON acc.BR_ACCT_NO = lm.BR_ACCT_NO
JOIN BUD_PROD_ITEM bpi
    ON bpi.PROD_ITEM_COD = acc.PROD_COD;




SELECT
    lm.BR_ACCT_NO,
    pg.ACTG_ENTY,
    pg.ACTV_ENTY_DES,
    acc.PROD_COD,
    bpi.BUS_PERS_IND
FROM PLM_LOAN_MATURITY lm
JOIN PLM_ACCOUNT acc
    ON acc.BR_ACCT_NO = lm.BR_ACCT_NO
JOIN PLM_BR_PROC_GRP pg
    ON pg.BR_NO BETWEEN
       TO_NUMBER(SUBSTR(lm.BR_ACCT_NO, 1, 6))
       AND TO_NUMBER(SUBSTR(lm.BR_ACCT_NO, 1, 6))
JOIN BUD_PROD_ITEM bpi
    ON bpi.PROD_ITEM_COD = acc.PROD_COD;


SELECT
    lm.BR_ACCT_NO,
    pg.ACTG_ENTY,
    pg.ACTV_ENTY_DES,
    acc.PROD_COD,
    bpi.BUS_PERS_IND
FROM PLM_BR_PROC_GRP pg
JOIN PLM_LOAN_MATURITY lm
    ON pg.BR_NO = SUBSTR(lm.BR_ACCT_NO, 1, 6)
JOIN PLM_ACCOUNT acc
    ON acc.BR_ACCT_NO = lm.BR_ACCT_NO
JOIN BUD_PROD_ITEM bpi
    ON bpi.PROD_ITEM_COD = acc.PROD_COD;



WITH date_groups AS (
    SELECT
        BR_ACCT_NO,
        FNL_RPAY_DT,
        FNL_RPAY_DT
          - ROW_NUMBER() OVER (
                PARTITION BY BR_ACCT_NO
                ORDER BY FNL_RPAY_DT
            ) AS grp
    FROM PLM_LOAN_MATURITY
),
qualified_accounts AS (
    SELECT BR_ACCT_NO
    FROM date_groups
    GROUP BY BR_ACCT_NO, grp
    HAVING COUNT(*) >= 2   -- use >=3 if you want strictly 3 days
)
SELECT *
FROM PLM_LOAN_MATURITY
WHERE BR_ACCT_NO IN (
    SELECT DISTINCT BR_ACCT_NO
    FROM qualified_accounts
);

SELECT
    r.PROD_ID,
    r.REFL_DT,
    r.TRAN_TYP_COD,
    r.FEE_AMT,
    acc.PROD_COD,
    bpi.BUS_PERS_IND,
    pg.ACTG_ENTY
FROM RMS_CR_TRAN_DECN r
JOIN PLM_ACCOUNT acc
    ON acc.PROD_ID = r.PROD_ID
JOIN BUD_PROD_ITEM bpi
    ON bpi.PROD_ITEM_COD = acc.PROD_COD
JOIN PLM_BR_PROC_GRP pg
    ON pg.BR_NO = SUBSTR(acc.BR_ACCT_NO, 1, 6)
WHERE r.REFL_DT = DATE('2026-02-03');




@RequestMapping(value = "/getProjects", method = RequestMethod.GET)
public JSONObject getProjectsbyyear(
        @RequestParam(required = false) Integer year,
        @RequestParam(required = false) String status,
        @RequestParam(required = false) String reportType) {

    JSONObject json = new JSONObject();
    JSONArray array = new JSONArray();

    List<ProjectDetails> projectList = new ArrayList<>();

    // üëâ Project Full View ONLY
    if ("projectFullView".equals(reportType) && year != null) {

        System.out.println("INSIDE PROJECT FULL VIEW");
        projectList = projectDao.getProjectsFullView(year);

    }
    // üëâ Existing logic untouched
    else if (year != null) {

        System.out.println("INSIDE IF OF GET PROJECTS");
        projectList = projectDao.getProjectsbyyear(year);

    } else if (status != null) {

        System.out.println("Inside ELSE OF GET PROJECTS");
        projectList = projectDao.getProjects(status);

    } else {

        projectList = projectDao.getProjects();
    }

    for (ProjectDetails r : projectList) {
        array.add(r);
    }

    json.put("data", array);
    return json;
}


public List<ProjectDetails> getProjectsFullView(int year) {

    List<String> readList = accessResolver.readAccessList();

    Date startDate = DateUtil.getYearStartDate(year);
    Date endDate   = DateUtil.getYearEndDate(year);

    // üîÅ Reuse EXISTING year logic
    List<ProjectDetails> projects =
            projectDetailsRepository.getProjectbyyear(
                    readList, startDate, endDate
            );

    // üî• Only teams ending with SVS
    return projects.stream()
            .filter(p ->
                    p.getForTeam() != null &&
                    p.getForTeam().trim().endsWith("SVS")
            )
            .toList();
}
