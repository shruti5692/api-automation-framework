package org.framework.utils;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.framework.utils.CryptoUtils;

import java.util.*;

/**
 * Generic JSON utilities that work with Maps instead of specific model classes.
 * Can extract data based on configurable field mappings.
 */
public class JsonUtils {
    
    private static final ObjectMapper mapper = new ObjectMapper();
    
    /**
     * Extract records from API response JSON using field mapping configuration
     * @param jsonResponse The JSON response string
     * @param arrayPath JSON path to the array (e.g., "data.accounts", "accounts")  
     * @param fieldMappings Map of target field name -> JSON field path
     * @return List of Maps with extracted and mapped fields
     */
    public static List<Map<String, String>> extractRecords(String jsonResponse, 
                                                          String arrayPath,
                                                          Map<String, String> fieldMappings) throws Exception {
        List<Map<String, String>> records = new ArrayList<>();
        
        JsonNode root = mapper.readTree(jsonResponse);
        JsonNode arrayNode = navigateToPath(root, arrayPath);
        
        if (!arrayNode.isArray()) {
            throw new IllegalArgumentException("Path " + arrayPath + " does not point to an array");
        }
        
        for (JsonNode item : arrayNode) {
            Map<String, String> record = new LinkedHashMap<>();
            
            for (Map.Entry<String, String> mapping : fieldMappings.entrySet()) {
                String targetField = mapping.getKey();
                String jsonPath = mapping.getValue();
                
                JsonNode valueNode = navigateToPath(item, jsonPath);
                String value = valueNode.isNull() ? "" : valueNode.asText();
                
                // Decrypt if needed (handles ENC(...) format)
                value = CryptoUtils.resolve(value);
                
                record.put(targetField, value);
            }
            
            records.add(record);
        }
        
        return records;
    }
    
    /**
     * Parse expected records from JSON string (array of objects)
     * @param expectedJson JSON string containing array of expected records
     * @param fieldMappings Optional field name mappings (null to use as-is)
     * @return List of Maps
     */
    public static List<Map<String, String>> parseExpectedRecords(String expectedJson, 
                                                               Map<String, String> fieldMappings) throws Exception {
        if (expectedJson == null || expectedJson.trim().isEmpty()) {
            return new ArrayList<>();
        }
        
        List<Map<String, String>> records = new ArrayList<>();
        JsonNode root = mapper.readTree(expectedJson);
        
        if (!root.isArray()) {
            throw new IllegalArgumentException("Expected JSON should be an array");
        }
        
        for (JsonNode item : root) {
            Map<String, String> record = new LinkedHashMap<>();
            
            if (fieldMappings != null) {
                // Use field mappings
                for (Map.Entry<String, String> mapping : fieldMappings.entrySet()) {
                    String targetField = mapping.getKey();
                    String sourceField = mapping.getValue();
                    
                    JsonNode valueNode = item.get(sourceField);
                    String value = valueNode == null || valueNode.isNull() ? "" : valueNode.asText();
                    value = CryptoUtils.resolve(value);
                    
                    record.put(targetField, value);
                }
            } else {
                // Use fields as-is
                Iterator<Map.Entry<String, JsonNode>> fields = item.fields();
                while (fields.hasNext()) {
                    Map.Entry<String, JsonNode> field = fields.next();
                    String key = field.getKey();
                    String value = field.getValue().isNull() ? "" : field.getValue().asText();
                    value = CryptoUtils.resolve(value);
                    record.put(key, value);
                }
            }
            
            records.add(record);
        }
        
        return records;
    }
    
    /**
     * Convert database rows to standardized Map format
     * @param dbRows List of database result rows
     * @param fieldMappings Map of target field -> DB column name
     * @return List of Maps with mapped fields
     */
    public static List<Map<String, String>> convertFromDbRows(List<Map<String, Object>> dbRows,
                                                            Map<String, String> fieldMappings) {
        List<Map<String, String>> records = new ArrayList<>();
        
        for (Map<String, Object> dbRow : dbRows) {
            Map<String, String> record = new LinkedHashMap<>();
            
            for (Map.Entry<String, String> mapping : fieldMappings.entrySet()) {
                String targetField = mapping.getKey();
                String dbColumn = mapping.getValue();
                
                Object value = dbRow.get(dbColumn);
                record.put(targetField, value == null ? "" : String.valueOf(value).trim());
            }
            
            records.add(record);
        }
        
        return records;
    }
    
    /**
     * Navigate to a nested JSON path (supports dot notation)
     * @param node Starting JSON node
     * @param path Dot-separated path (e.g., "data.accounts" or "productCode")
     * @return JsonNode at the specified path
     */
    private static JsonNode navigateToPath(JsonNode node, String path) {
        if (path == null || path.trim().isEmpty()) {
            return node;
        }
        
        String[] parts = path.split("\\.");
        JsonNode current = node;
        
        for (String part : parts) {
            if (current.isNull() || !current.has(part)) {
                return mapper.createObjectNode().nullNode();
            }
            current = current.get(part);
        }
        
        return current;
    }
}
